[<< 返回](../README.md)
## 特色案例
通用平差模型已经覆盖了各种情形，然而通用模型会当成普通网形进行求解，会把所有约束，观测，待定点，创建全局map，建立系数矩阵，组成法方程。这个的内部实现是一个相对复杂的过程。因而针对一些常见情景，我们提供了一套高效实现。

### 后方交会
高效实现的观测输入必须是未知点的 station 记录，以及后面接一系列的朝向已知点的 ts 观测。
```python
# 后方交汇
points = [
    ('TN2', 1000, 1000, 101, True),
    ('TN8', 1367.77286, 1117.43005, 102, True),
    ('TN9', 1294.76794, 1789.72043, 103, True),
    ('TN1', 893, 1603, 100, False)]

measures = [
    ('station', 'TN1', None),
    ('ts', 'TN1', 'TN2', 0, 0.00163, 612.41862),
    ('ts', 'TN1', 'TN8', 0.598815, 0.00294, 678.73168),
    ('ts', 'TN1', 'TN9', 1.8317007, 0.00678, 442.39598)
]

print('\n后方交汇(高效算法)')
measx = mfit.ts2ahds(measures, 1, 1, 1, K=1) # 全站仪数据转水平角，高差，平距
rst, sta = mfit.backward_x(points, measx)
print(mfit.report([rst]))
```
#### 点位信息及精度

| name | x          | y          | h        | type  | dxx   | dxy   | dyy   | dhh   |
|------|------------|------------|----------|-------|-------|-------|-------|-------|
| TN1  | 893.6626   | 1603.1170  | 100.0018 | False | 0.8691| 0.1680| 0.8189| 2.3630|

**优化点如下**：
* 求解函数会根据约定的规则构建系数矩阵，比通用构建方法高效
* 法方程事先知道是3x3，对于小规模矩阵行列式求逆，比高斯消元法快。
* 对于工程上常用的后方交汇，高效实现略去了最弱边角等观测精度评估，只计算点位误差。

### 极坐标求解
极坐标求解，输入必须是一个已知点的 station ，向一系列测点的观测，其中第一个必须是定向点。
```python
points = [
    ('P1', 0, 0, 0, True),
    ('P2', 1000, 0, 0, True),
    ('Px', 1000, 577, 100, False)
]

# A站观测
meas_a = [
    ('station', 'P1', None),
    ('ts', 'P1', 'P2', 0, 0, 1000),
    ('ts', 'P1', 'Px', 0.52359, 0.0864, 1158.84),
    # 这里可以有更多未知点观测记录
]

# B站观测
meas_b = [
    ('station', 'P2', None),
    ('ts', 'P2', 'P1', 3.141592, 0, 1000),
    ('ts', 'P2', 'Px', 1.57079, 0.17151, 585.94),
    # 这里可以有更多未知点观测记录
]
```
下面我们来求解A，B两个测站的极坐标
```python
# 改正，转高差，平距
meas = mfit.ts_adjusts(meas_a, b=0, k=1, ppm=0)
meas = mfit.ts2ahds(meas, 1, 1, 1, K=1)
xyh_a = mfit.polar(points, meas)
print('\nA站极坐标(高效算法)')
print(mfit.report(xyh_a))
```
#### 点位信息及精度
| name | x          | y          | h        | type  | dxx       | dxy       | dyy       | dhh       |
|------|------------|------------|----------|-------|-----------|-----------|-----------|-----------|
| Px   | 999.8464   | 577.2499   | 99.9993  | False | 17.5846   | -26.0230  | 47.6345   | 31.3467   |

```python
# 改正，转高差，平距
meas = mfit.ts_adjusts(meas_b, b=0, k=1, ppm=0)
meas = mfit.ts2ahds(meas, 1, 1, 1, K=1)
xyh_b = mfit.polar(points, meas)
print('\nB站极坐标(高效算法)')
print(mfit.report(xyh_b))
```

#### 点位信息及精度

| name | x          | y          | h        | type  | dxx       | dxy       | dyy       | dhh       |
|------|------------|------------|----------|-------|-----------|-----------|-----------|-----------|
| Px   | 1000.0033  | 577.3432   | 100.0026 | False | 15.6692   | -0.0001   | 1.5393    | 7.8737    |


**优化点如下**：

* 其实这里并没有进行求解，是根据定向点计算定向角，然后逐一计算出各个测点的坐标。
* 计算坐标的同时利用协方差传播律，计算出点位精度。

### 极坐标融合
上述A，B两站的计算结果，可以直接进行融合，结果等同于前方交会。支持多站，并且每站的数据不要求一致。就是最终结果可以是部分点极坐标，部分双站，部分三站或更多。
```python
xyh_ab = mfit.merge_xyhs([xyh_a, xyh_b])
print('\nAB站极坐标成果融合（高效算法）')
print(mfit.report(xyh_ab))
```

#### 点位信息及精度

| name | x          | y          | h        | type  | dxx       | dxy       | dyy       | dhh       |
|------|------------|------------|----------|-------|-----------|-----------|-----------|-----------|
| Px   | 999.8374   | 577.3317   | 100.0019 | False | 3.0668    | -0.6552   | 1.4570    | 6.2930    |

### 前方交汇
前方交汇高效实现，实质上是计算出各个站的极坐标，然后极坐标成果融合
```python
meas = mfit.ts_adjusts(meas_a + meas_b, b=0, k=1, ppm=0) # 加乘常数改正，气象改正
meas = mfit.ts2ahds(meas, 1, 1, 1, K=1) # 全站仪数据转水平角，高差，平距
xyh_abx = mfit.forward_x(points, meas)
print('\nAB站前方交汇（高效算法，利用AB极坐标的结果进行融合）')
print(mfit.report(xyh_abx))
```

#### 点位信息及精度

| name | x          | y          | h        | type  | dxx       | dxy       | dyy       | dhh       |
|------|------------|------------|----------|-------|-----------|-----------|-----------|-----------|
| Px   | 999.8374   | 577.3317   | 100.0019 | False | 3.0668    | -0.6552   | 1.4570    | 6.2930    |

**优化点如下**：
* 极坐标融合，使用卡尔曼滤波算法，因为各个观测的系数矩阵都是 E，因此退化成了协方差矩阵的加权。
* 协方差矩阵都是XYH的3x3矩阵，对于小规模矩阵行列式求逆，比高斯消元法快。